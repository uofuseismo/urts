<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>URTS: URTS::Services::Scalable::PacketCache::WigginsInterpolator Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
  $(document).ready(function() { init_search(); });
/* @license-end */
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">URTS
   </div>
   <div id="projectbrief">The University of Utah Seismograph Stations Real-Time Seismology package.</div>
  </td>
    <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <span id="MSearchSelect"                onmouseover="return searchBox.OnSearchSelectShow()"                onmouseout="return searchBox.OnSearchSelectHide()">&#160;</span>
          <input type="text" id="MSearchField" value="" placeholder="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.svg" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('class_u_r_t_s_1_1_services_1_1_scalable_1_1_packet_cache_1_1_wiggins_interpolator.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="class_u_r_t_s_1_1_services_1_1_scalable_1_1_packet_cache_1_1_wiggins_interpolator-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">URTS::Services::Scalable::PacketCache::WigginsInterpolator Class Reference</div></div>
</div><!--header-->
<div class="contents">

<p>Performs Wiggins interpolation on a vector of data packets. This can heal the packets returned by a packet cache query.  
 <a href="class_u_r_t_s_1_1_services_1_1_scalable_1_1_packet_cache_1_1_wiggins_interpolator.html#details">More...</a></p>

<p><code>#include &quot;<a class="el" href="wiggins_interpolator_8hpp_source.html">urts/services/scalable/packetCache/wigginsInterpolator.hpp</a>&quot;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr><td colspan="2"><div class="groupHeader">Constructors</div></td></tr>
<tr class="memitem:a876d0f17190b320da33c1c2d4025e5d4" id="r_a876d0f17190b320da33c1c2d4025e5d4"><td class="memItemLeft" align="right" valign="top"><a id="a876d0f17190b320da33c1c2d4025e5d4" name="a876d0f17190b320da33c1c2d4025e5d4"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>WigginsInterpolator</b> ()</td></tr>
<tr class="memdesc:a876d0f17190b320da33c1c2d4025e5d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor. <br /></td></tr>
<tr class="separator:a876d0f17190b320da33c1c2d4025e5d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace14486c88d23d862b813ccfac4a00b3" id="r_ace14486c88d23d862b813ccfac4a00b3"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_u_r_t_s_1_1_services_1_1_scalable_1_1_packet_cache_1_1_wiggins_interpolator.html#ace14486c88d23d862b813ccfac4a00b3">WigginsInterpolator</a> (const <a class="el" href="class_u_r_t_s_1_1_services_1_1_scalable_1_1_packet_cache_1_1_wiggins_interpolator.html">WigginsInterpolator</a> &amp;wiggins)</td></tr>
<tr class="memdesc:ace14486c88d23d862b813ccfac4a00b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy constructor.  <br /></td></tr>
<tr class="separator:ace14486c88d23d862b813ccfac4a00b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c8e4ac25a9d6e67e7e8de9c85229074" id="r_a2c8e4ac25a9d6e67e7e8de9c85229074"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_u_r_t_s_1_1_services_1_1_scalable_1_1_packet_cache_1_1_wiggins_interpolator.html#a2c8e4ac25a9d6e67e7e8de9c85229074">WigginsInterpolator</a> (<a class="el" href="class_u_r_t_s_1_1_services_1_1_scalable_1_1_packet_cache_1_1_wiggins_interpolator.html">WigginsInterpolator</a> &amp;&amp;wiggins) noexcept</td></tr>
<tr class="memdesc:a2c8e4ac25a9d6e67e7e8de9c85229074"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move constructor.  <br /></td></tr>
<tr class="separator:a2c8e4ac25a9d6e67e7e8de9c85229074"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Operators</div></td></tr>
<tr class="memitem:ae084aeb4541c608ffcb20620129252eb" id="r_ae084aeb4541c608ffcb20620129252eb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_u_r_t_s_1_1_services_1_1_scalable_1_1_packet_cache_1_1_wiggins_interpolator.html">WigginsInterpolator</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_u_r_t_s_1_1_services_1_1_scalable_1_1_packet_cache_1_1_wiggins_interpolator.html#ae084aeb4541c608ffcb20620129252eb">operator=</a> (const <a class="el" href="class_u_r_t_s_1_1_services_1_1_scalable_1_1_packet_cache_1_1_wiggins_interpolator.html">WigginsInterpolator</a> &amp;wiggins)</td></tr>
<tr class="memdesc:ae084aeb4541c608ffcb20620129252eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy assigment.  <br /></td></tr>
<tr class="separator:ae084aeb4541c608ffcb20620129252eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a580bc0ff7e59068c39ac5da546fb124c" id="r_a580bc0ff7e59068c39ac5da546fb124c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_u_r_t_s_1_1_services_1_1_scalable_1_1_packet_cache_1_1_wiggins_interpolator.html">WigginsInterpolator</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_u_r_t_s_1_1_services_1_1_scalable_1_1_packet_cache_1_1_wiggins_interpolator.html#a580bc0ff7e59068c39ac5da546fb124c">operator=</a> (<a class="el" href="class_u_r_t_s_1_1_services_1_1_scalable_1_1_packet_cache_1_1_wiggins_interpolator.html">WigginsInterpolator</a> &amp;&amp;wiggins) noexcept</td></tr>
<tr class="memdesc:a580bc0ff7e59068c39ac5da546fb124c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move assignment.  <br /></td></tr>
<tr class="separator:a580bc0ff7e59068c39ac5da546fb124c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Target Sampling Rate</div></td></tr>
<tr class="memitem:a2a97e30863b14db61aecfe96aa985761" id="r_a2a97e30863b14db61aecfe96aa985761"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_u_r_t_s_1_1_services_1_1_scalable_1_1_packet_cache_1_1_wiggins_interpolator.html#a2a97e30863b14db61aecfe96aa985761">setTargetSamplingRate</a> (double samplingRate)</td></tr>
<tr class="memdesc:a2a97e30863b14db61aecfe96aa985761"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the target sampling rate. This is the sampling rate to which signals will be interpolated.  <br /></td></tr>
<tr class="separator:a2a97e30863b14db61aecfe96aa985761"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd5dd03f214a3bc956ef09cff6360f06" id="r_afd5dd03f214a3bc956ef09cff6360f06"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_u_r_t_s_1_1_services_1_1_scalable_1_1_packet_cache_1_1_wiggins_interpolator.html#afd5dd03f214a3bc956ef09cff6360f06">getTargetSamplingRate</a> () const noexcept</td></tr>
<tr class="separator:afd5dd03f214a3bc956ef09cff6360f06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Gap Tolerance</div></td></tr>
<tr class="memitem:a8540192aead712dedf34df716060e456" id="r_a8540192aead712dedf34df716060e456"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_u_r_t_s_1_1_services_1_1_scalable_1_1_packet_cache_1_1_wiggins_interpolator.html#a8540192aead712dedf34df716060e456">setGapTolerance</a> (const std::chrono::microseconds &amp;tolerance) noexcept</td></tr>
<tr class="memdesc:a8540192aead712dedf34df716060e456"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the gap tolerance between packets.  <br /></td></tr>
<tr class="separator:a8540192aead712dedf34df716060e456"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af73609dbd4bdf10a6753a75edaf1dd40" id="r_af73609dbd4bdf10a6753a75edaf1dd40"><td class="memItemLeft" align="right" valign="top">std::chrono::microseconds&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_u_r_t_s_1_1_services_1_1_scalable_1_1_packet_cache_1_1_wiggins_interpolator.html#af73609dbd4bdf10a6753a75edaf1dd40">getGapTolerance</a> () const noexcept</td></tr>
<tr class="separator:af73609dbd4bdf10a6753a75edaf1dd40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Interpolate</div></td></tr>
<tr class="memitem:a8d430942f11eef81a70e94f96266a3e3" id="r_a8d430942f11eef81a70e94f96266a3e3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_u_r_t_s_1_1_services_1_1_scalable_1_1_packet_cache_1_1_wiggins_interpolator.html#a8d430942f11eef81a70e94f96266a3e3">interpolate</a> (const std::vector&lt; <a class="el" href="class_u_r_t_s_1_1_broadcasts_1_1_internal_1_1_data_packet_1_1_data_packet.html">URTS::Broadcasts::Internal::DataPacket::DataPacket</a> &gt; &amp;packets, const std::chrono::microseconds &amp;startTime=std::chrono::microseconds {-631152000000000}, const std::chrono::microseconds &amp;endtime=std::chrono::microseconds {5680281600000000})</td></tr>
<tr class="memdesc:a8d430942f11eef81a70e94f96266a3e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interpolates the data packets. This will interpolate from the earliest time in the colleciton of packets up to the latest time in the packets.  <br /></td></tr>
<tr class="separator:a8d430942f11eef81a70e94f96266a3e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a17bfd0745d2436fed6f8dab6c27913" id="r_a1a17bfd0745d2436fed6f8dab6c27913"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_u_r_t_s_1_1_services_1_1_scalable_1_1_packet_cache_1_1_wiggins_interpolator.html#a1a17bfd0745d2436fed6f8dab6c27913">interpolate</a> (int nPackets, const <a class="el" href="class_u_r_t_s_1_1_broadcasts_1_1_internal_1_1_data_packet_1_1_data_packet.html">URTS::Broadcasts::Internal::DataPacket::DataPacket</a> packets[], const std::chrono::microseconds &amp;startTime=std::chrono::microseconds {-631152000000000}, const std::chrono::microseconds &amp;endtime=std::chrono::microseconds {5680281600000000})</td></tr>
<tr class="memdesc:a1a17bfd0745d2436fed6f8dab6c27913"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interpolates the data packets.  <br /></td></tr>
<tr class="separator:a1a17bfd0745d2436fed6f8dab6c27913"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Interpolated Signal</div></td></tr>
<tr class="memitem:afd27bf2159bf3bc305b8843c35a0b49a" id="r_afd27bf2159bf3bc305b8843c35a0b49a"><td class="memItemLeft" align="right" valign="top">std::vector&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_u_r_t_s_1_1_services_1_1_scalable_1_1_packet_cache_1_1_wiggins_interpolator.html#afd27bf2159bf3bc305b8843c35a0b49a">getSignal</a> () const noexcept</td></tr>
<tr class="separator:afd27bf2159bf3bc305b8843c35a0b49a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1574b811342630164808d459acd7117" id="r_ae1574b811342630164808d459acd7117"><td class="memItemLeft" align="right" valign="top">const double *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_u_r_t_s_1_1_services_1_1_scalable_1_1_packet_cache_1_1_wiggins_interpolator.html#ae1574b811342630164808d459acd7117">getSignalPointer</a> () const noexcept</td></tr>
<tr class="separator:ae1574b811342630164808d459acd7117"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe59094d0e892f179c558e1227e12433" id="r_abe59094d0e892f179c558e1227e12433"><td class="memItemLeft" align="right" valign="top">const std::vector&lt; double &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_u_r_t_s_1_1_services_1_1_scalable_1_1_packet_cache_1_1_wiggins_interpolator.html#abe59094d0e892f179c558e1227e12433">getSignalReference</a> () const noexcept</td></tr>
<tr class="separator:abe59094d0e892f179c558e1227e12433"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb6299b38939ae014c3e392233e9fd9f" id="r_afb6299b38939ae014c3e392233e9fd9f"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_u_r_t_s_1_1_services_1_1_scalable_1_1_packet_cache_1_1_wiggins_interpolator.html#afb6299b38939ae014c3e392233e9fd9f">getNumberOfSamples</a> () const noexcept</td></tr>
<tr class="separator:afb6299b38939ae014c3e392233e9fd9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aedb33581c8a85dd17440feb61b0ef763" id="r_aedb33581c8a85dd17440feb61b0ef763"><td class="memItemLeft" align="right" valign="top">std::vector&lt; int8_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_u_r_t_s_1_1_services_1_1_scalable_1_1_packet_cache_1_1_wiggins_interpolator.html#aedb33581c8a85dd17440feb61b0ef763">getGapIndicator</a> () const noexcept</td></tr>
<tr class="separator:aedb33581c8a85dd17440feb61b0ef763"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace375759b37b710e1bdb758c2874ad9b" id="r_ace375759b37b710e1bdb758c2874ad9b"><td class="memItemLeft" align="right" valign="top">const int8_t *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_u_r_t_s_1_1_services_1_1_scalable_1_1_packet_cache_1_1_wiggins_interpolator.html#ace375759b37b710e1bdb758c2874ad9b">getGapIndicatorPointer</a> () const noexcept</td></tr>
<tr class="separator:ace375759b37b710e1bdb758c2874ad9b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afabd742476f33f141436dc5b74bb1db3" id="r_afabd742476f33f141436dc5b74bb1db3"><td class="memItemLeft" align="right" valign="top">const std::vector&lt; int8_t &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_u_r_t_s_1_1_services_1_1_scalable_1_1_packet_cache_1_1_wiggins_interpolator.html#afabd742476f33f141436dc5b74bb1db3">getGapIndicatorReference</a> () const noexcept</td></tr>
<tr class="separator:afabd742476f33f141436dc5b74bb1db3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21bf4094c6e8d979556405a1acf036ae" id="r_a21bf4094c6e8d979556405a1acf036ae"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_u_r_t_s_1_1_services_1_1_scalable_1_1_packet_cache_1_1_wiggins_interpolator.html#a21bf4094c6e8d979556405a1acf036ae">haveGaps</a> () const noexcept</td></tr>
<tr class="separator:a21bf4094c6e8d979556405a1acf036ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f96bb48e20fd7bc017d8ba660824ea4" id="r_a2f96bb48e20fd7bc017d8ba660824ea4"><td class="memItemLeft" align="right" valign="top">std::chrono::microseconds&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_u_r_t_s_1_1_services_1_1_scalable_1_1_packet_cache_1_1_wiggins_interpolator.html#a2f96bb48e20fd7bc017d8ba660824ea4">getStartTime</a> () const noexcept</td></tr>
<tr class="separator:a2f96bb48e20fd7bc017d8ba660824ea4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3753a1421d10794384756261b2d106e" id="r_aa3753a1421d10794384756261b2d106e"><td class="memItemLeft" align="right" valign="top">std::chrono::microseconds&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_u_r_t_s_1_1_services_1_1_scalable_1_1_packet_cache_1_1_wiggins_interpolator.html#aa3753a1421d10794384756261b2d106e">getEndTime</a> () const noexcept</td></tr>
<tr class="separator:aa3753a1421d10794384756261b2d106e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Destructors</div></td></tr>
<tr class="memitem:a60a1442d67015aa31ca0711c41f8eee2" id="r_a60a1442d67015aa31ca0711c41f8eee2"><td class="memItemLeft" align="right" valign="top"><a id="a60a1442d67015aa31ca0711c41f8eee2" name="a60a1442d67015aa31ca0711c41f8eee2"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>clear</b> () noexcept</td></tr>
<tr class="memdesc:a60a1442d67015aa31ca0711c41f8eee2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resets the class and releases all memory. <br /></td></tr>
<tr class="separator:a60a1442d67015aa31ca0711c41f8eee2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a388533620c4fd1a372913af3f3656461" id="r_a388533620c4fd1a372913af3f3656461"><td class="memItemLeft" align="right" valign="top"><a id="a388533620c4fd1a372913af3f3656461" name="a388533620c4fd1a372913af3f3656461"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>clearSignal</b> () noexcept</td></tr>
<tr class="memdesc:a388533620c4fd1a372913af3f3656461"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resets the start/end time to zero and releases memory of the gap pointer and signal. This will not modify the gap tolerance or target sampling rate. <br /></td></tr>
<tr class="separator:a388533620c4fd1a372913af3f3656461"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1efae9b5703dc410de64fc7be2bb42a1" id="r_a1efae9b5703dc410de64fc7be2bb42a1"><td class="memItemLeft" align="right" valign="top"><a id="a1efae9b5703dc410de64fc7be2bb42a1" name="a1efae9b5703dc410de64fc7be2bb42a1"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>~WigginsInterpolator</b> ()</td></tr>
<tr class="memdesc:a1efae9b5703dc410de64fc7be2bb42a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor. <br /></td></tr>
<tr class="separator:a1efae9b5703dc410de64fc7be2bb42a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Performs Wiggins interpolation on a vector of data packets. This can heal the packets returned by a packet cache query. </p>
<dl class="section copyright"><dt>Copyright</dt><dd>Ben Baker (University of Utah) distributed under the MIT license. </dd></dl>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="ace14486c88d23d862b813ccfac4a00b3" name="ace14486c88d23d862b813ccfac4a00b3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ace14486c88d23d862b813ccfac4a00b3">&#9670;&#160;</a></span>WigginsInterpolator() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">URTS::Services::Scalable::PacketCache::WigginsInterpolator::WigginsInterpolator </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_u_r_t_s_1_1_services_1_1_scalable_1_1_packet_cache_1_1_wiggins_interpolator.html">WigginsInterpolator</a> &amp;&#160;</td>
          <td class="paramname"><em>wiggins</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copy constructor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">wiggins</td><td>The interpolator from which to initialize this class. <br  />
 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2c8e4ac25a9d6e67e7e8de9c85229074" name="a2c8e4ac25a9d6e67e7e8de9c85229074"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2c8e4ac25a9d6e67e7e8de9c85229074">&#9670;&#160;</a></span>WigginsInterpolator() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">URTS::Services::Scalable::PacketCache::WigginsInterpolator::WigginsInterpolator </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_u_r_t_s_1_1_services_1_1_scalable_1_1_packet_cache_1_1_wiggins_interpolator.html">WigginsInterpolator</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>wiggins</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Move constructor. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">wiggins</td><td>The interpolator from which to initialize this class. On exit, wiggins's behavior is undefined. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="aa3753a1421d10794384756261b2d106e" name="aa3753a1421d10794384756261b2d106e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa3753a1421d10794384756261b2d106e">&#9670;&#160;</a></span>getEndTime()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::chrono::microseconds URTS::Services::Scalable::PacketCache::WigginsInterpolator::getEndTime </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>The end time of the interpolated signal. </dd></dl>

</div>
</div>
<a id="aedb33581c8a85dd17440feb61b0ef763" name="aedb33581c8a85dd17440feb61b0ef763"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aedb33581c8a85dd17440feb61b0ef763">&#9670;&#160;</a></span>getGapIndicator()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; int8_t &gt; URTS::Services::Scalable::PacketCache::WigginsInterpolator::getGapIndicator </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>An array of true/false that indicates whether or not the interpolated signal fell between packet endpoints. <br  />
 </dd></dl>

</div>
</div>
<a id="ace375759b37b710e1bdb758c2874ad9b" name="ace375759b37b710e1bdb758c2874ad9b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ace375759b37b710e1bdb758c2874ad9b">&#9670;&#160;</a></span>getGapIndicatorPointer()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const int8_t * URTS::Services::Scalable::PacketCache::WigginsInterpolator::getGapIndicatorPointer </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>A pointer to a signal that indicates whether or not the sample in the interpolated signal was within a packet (false) or between packets (true) - i.e., extrapolated. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>This exists for performance reasons. When possibleu se <code><a class="el" href="class_u_r_t_s_1_1_services_1_1_scalable_1_1_packet_cache_1_1_wiggins_interpolator.html#aedb33581c8a85dd17440feb61b0ef763">getGapIndicator()</a></code>. </dd></dl>

</div>
</div>
<a id="afabd742476f33f141436dc5b74bb1db3" name="afabd742476f33f141436dc5b74bb1db3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afabd742476f33f141436dc5b74bb1db3">&#9670;&#160;</a></span>getGapIndicatorReference()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::vector&lt; int8_t &gt; &amp; URTS::Services::Scalable::PacketCache::WigginsInterpolator::getGapIndicatorReference </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>A pointer to a signal that indicates whether or not the sample in the interpolated signal was within a packet (false) or between packets (true) - i.e., extrapolated. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>This exists for performance reasons. When possibleu se <code><a class="el" href="class_u_r_t_s_1_1_services_1_1_scalable_1_1_packet_cache_1_1_wiggins_interpolator.html#aedb33581c8a85dd17440feb61b0ef763">getGapIndicator()</a></code>. </dd></dl>

</div>
</div>
<a id="af73609dbd4bdf10a6753a75edaf1dd40" name="af73609dbd4bdf10a6753a75edaf1dd40"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af73609dbd4bdf10a6753a75edaf1dd40">&#9670;&#160;</a></span>getGapTolerance()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::chrono::microseconds URTS::Services::Scalable::PacketCache::WigginsInterpolator::getGapTolerance </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>The gap tolerance. By default this is 30000 (0.03 seconds) or 3 samples at the nominal sampling rate of 100 Hz. </dd></dl>

</div>
</div>
<a id="afb6299b38939ae014c3e392233e9fd9f" name="afb6299b38939ae014c3e392233e9fd9f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afb6299b38939ae014c3e392233e9fd9f">&#9670;&#160;</a></span>getNumberOfSamples()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int URTS::Services::Scalable::PacketCache::WigginsInterpolator::getNumberOfSamples </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>The number of samples in the interpolated signal. </dd></dl>

</div>
</div>
<a id="afd27bf2159bf3bc305b8843c35a0b49a" name="afd27bf2159bf3bc305b8843c35a0b49a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afd27bf2159bf3bc305b8843c35a0b49a">&#9670;&#160;</a></span>getSignal()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; double &gt; URTS::Services::Scalable::PacketCache::WigginsInterpolator::getSignal </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>The interpolated signal. </dd></dl>

</div>
</div>
<a id="ae1574b811342630164808d459acd7117" name="ae1574b811342630164808d459acd7117"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae1574b811342630164808d459acd7117">&#9670;&#160;</a></span>getSignalPointer()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const double * URTS::Services::Scalable::PacketCache::WigginsInterpolator::getSignalPointer </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>A pointer to the interpolated signal. This is an array whose dimension is [<code>getNumberOfSamples</code>]. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>This exists for performance reasons. When possible use <code><a class="el" href="class_u_r_t_s_1_1_services_1_1_scalable_1_1_packet_cache_1_1_wiggins_interpolator.html#afd27bf2159bf3bc305b8843c35a0b49a">getSignal()</a></code>. </dd></dl>

</div>
</div>
<a id="abe59094d0e892f179c558e1227e12433" name="abe59094d0e892f179c558e1227e12433"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abe59094d0e892f179c558e1227e12433">&#9670;&#160;</a></span>getSignalReference()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::vector&lt; double &gt; &amp; URTS::Services::Scalable::PacketCache::WigginsInterpolator::getSignalReference </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>A pointer to the interpolated signal. This is an array whose dimension is [<code>getNumberOfSamples</code>]. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>This exists for performance reasons. When possible use <code><a class="el" href="class_u_r_t_s_1_1_services_1_1_scalable_1_1_packet_cache_1_1_wiggins_interpolator.html#afd27bf2159bf3bc305b8843c35a0b49a">getSignal()</a></code>. </dd></dl>

</div>
</div>
<a id="a2f96bb48e20fd7bc017d8ba660824ea4" name="a2f96bb48e20fd7bc017d8ba660824ea4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2f96bb48e20fd7bc017d8ba660824ea4">&#9670;&#160;</a></span>getStartTime()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::chrono::microseconds URTS::Services::Scalable::PacketCache::WigginsInterpolator::getStartTime </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>The start time of the interpolated signal. </dd></dl>

</div>
</div>
<a id="afd5dd03f214a3bc956ef09cff6360f06" name="afd5dd03f214a3bc956ef09cff6360f06"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afd5dd03f214a3bc956ef09cff6360f06">&#9670;&#160;</a></span>getTargetSamplingRate()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double URTS::Services::Scalable::PacketCache::WigginsInterpolator::getTargetSamplingRate </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>The nominal sampling ratein Hz. By default this is 100 Hz. </dd></dl>

</div>
</div>
<a id="a21bf4094c6e8d979556405a1acf036ae" name="a21bf4094c6e8d979556405a1acf036ae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a21bf4094c6e8d979556405a1acf036ae">&#9670;&#160;</a></span>haveGaps()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool URTS::Services::Scalable::PacketCache::WigginsInterpolator::haveGaps </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>True indicates that there are non-zeros in the gapIndicator. </dd></dl>

</div>
</div>
<a id="a8d430942f11eef81a70e94f96266a3e3" name="a8d430942f11eef81a70e94f96266a3e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8d430942f11eef81a70e94f96266a3e3">&#9670;&#160;</a></span>interpolate() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void URTS::Services::Scalable::PacketCache::WigginsInterpolator::interpolate </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="class_u_r_t_s_1_1_broadcasts_1_1_internal_1_1_data_packet_1_1_data_packet.html">URTS::Broadcasts::Internal::DataPacket::DataPacket</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>packets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::chrono::microseconds &amp;&#160;</td>
          <td class="paramname"><em>startTime</em> = <code>std::chrono::microseconds&#160;{-631152000000000}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::chrono::microseconds &amp;&#160;</td>
          <td class="paramname"><em>endtime</em> = <code>std::chrono::microseconds&#160;{5680281600000000}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Interpolates the data packets. This will interpolate from the earliest time in the colleciton of packets up to the latest time in the packets. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">packets</td><td>The packets to interpolate. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">startTime</td><td>The start time (UTC) in microseconds since the epoch of the interpolation. If this is less than the minimum start time of all the packets then the interpolation will start at the minimum start time of all packets. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">endTime</td><td>The end time (UTC) in microseconds since the epoch of the interpolation. If this is greater than the maximum end time of all the packets then the interpolation will end at the maximum end time of all packets. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::runtime_error</td><td>if an error occurs. </td></tr>
    <tr><td class="paramname">std::invalid_argument</td><td>if the start time exceeds the end time. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1a17bfd0745d2436fed6f8dab6c27913" name="a1a17bfd0745d2436fed6f8dab6c27913"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1a17bfd0745d2436fed6f8dab6c27913">&#9670;&#160;</a></span>interpolate() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void URTS::Services::Scalable::PacketCache::WigginsInterpolator::interpolate </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nPackets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_u_r_t_s_1_1_broadcasts_1_1_internal_1_1_data_packet_1_1_data_packet.html">URTS::Broadcasts::Internal::DataPacket::DataPacket</a>&#160;</td>
          <td class="paramname"><em>packets</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::chrono::microseconds &amp;&#160;</td>
          <td class="paramname"><em>startTime</em> = <code>std::chrono::microseconds&#160;{-631152000000000}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::chrono::microseconds &amp;&#160;</td>
          <td class="paramname"><em>endtime</em> = <code>std::chrono::microseconds&#160;{5680281600000000}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Interpolates the data packets. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">nPackets</td><td>The number of packets (which must be positive). @parma[in] packets An array of data packets. This has dimension [nPackets]. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">startTime</td><td>The start time (UTC) in microseconds since the epoch of the interpolation. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">endTime</td><td>The end time (UTC) in microsecond since the epoch of the interpolation. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td>if the start time exceeds the end time, the number of packets is positive and packets is NULL. <br  />
 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae084aeb4541c608ffcb20620129252eb" name="ae084aeb4541c608ffcb20620129252eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae084aeb4541c608ffcb20620129252eb">&#9670;&#160;</a></span>operator=() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_u_r_t_s_1_1_services_1_1_scalable_1_1_packet_cache_1_1_wiggins_interpolator.html">WigginsInterpolator</a> &amp; URTS::Services::Scalable::PacketCache::WigginsInterpolator::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_u_r_t_s_1_1_services_1_1_scalable_1_1_packet_cache_1_1_wiggins_interpolator.html">WigginsInterpolator</a> &amp;&#160;</td>
          <td class="paramname"><em>wiggins</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copy assigment. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">wiggins</td><td>The interpolator class to copy to this. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A deep copy of the wiggins interpolator. </dd></dl>

</div>
</div>
<a id="a580bc0ff7e59068c39ac5da546fb124c" name="a580bc0ff7e59068c39ac5da546fb124c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a580bc0ff7e59068c39ac5da546fb124c">&#9670;&#160;</a></span>operator=() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_u_r_t_s_1_1_services_1_1_scalable_1_1_packet_cache_1_1_wiggins_interpolator.html">WigginsInterpolator</a> &amp; URTS::Services::Scalable::PacketCache::WigginsInterpolator::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_u_r_t_s_1_1_services_1_1_scalable_1_1_packet_cache_1_1_wiggins_interpolator.html">WigginsInterpolator</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>wiggins</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Move assignment. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">wiggins</td><td>The class whose memory will be moved to this. On exit, wiggins's behavior is undefined. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the memory form wiggins moved to this. </dd></dl>

</div>
</div>
<a id="a8540192aead712dedf34df716060e456" name="a8540192aead712dedf34df716060e456"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8540192aead712dedf34df716060e456">&#9670;&#160;</a></span>setGapTolerance()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void URTS::Services::Scalable::PacketCache::WigginsInterpolator::setGapTolerance </td>
          <td>(</td>
          <td class="paramtype">const std::chrono::microseconds &amp;&#160;</td>
          <td class="paramname"><em>tolerance</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the gap tolerance between packets. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">tolerance</td><td>If the time between the end of a packet and the start of the next packet exceeds this time then the samples interpolated between the packets will be denoted as extrapolated data gaps. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Zero or negative effectively disables this. In which case any sample interpolated between a packet is being extrapolated in a gap. </dd></dl>

</div>
</div>
<a id="a2a97e30863b14db61aecfe96aa985761" name="a2a97e30863b14db61aecfe96aa985761"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2a97e30863b14db61aecfe96aa985761">&#9670;&#160;</a></span>setTargetSamplingRate()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void URTS::Services::Scalable::PacketCache::WigginsInterpolator::setTargetSamplingRate </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>samplingRate</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the target sampling rate. This is the sampling rate to which signals will be interpolated. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">samplingRate</td><td>The sampling rate, in Hz, to which the packets will be interpolated. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td>if this is not positive. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>include/urts/services/scalable/packetCache/<a class="el" href="wiggins_interpolator_8hpp_source.html">wigginsInterpolator.hpp</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><b>URTS</b></li><li class="navelem"><b>Services</b></li><li class="navelem"><b>Scalable</b></li><li class="navelem"><b>PacketCache</b></li><li class="navelem"><a class="el" href="class_u_r_t_s_1_1_services_1_1_scalable_1_1_packet_cache_1_1_wiggins_interpolator.html">WigginsInterpolator</a></li>
    <li class="footer">Generated on Wed Jun 4 2025 16:16:24 for URTS by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8 </li>
  </ul>
</div>
</body>
</html>
